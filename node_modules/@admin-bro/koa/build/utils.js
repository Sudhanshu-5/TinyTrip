"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyAdminBro = exports.addAdminBroAuthRoutes = exports.addAdminBroRoutes = void 0;
const admin_bro_1 = __importDefault(require("admin-bro"));
const koa_mount_1 = __importDefault(require("koa-mount"));
const koa_static_1 = __importDefault(require("koa-static"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const addAdminBroRoutes = (admin, router, app) => {
    const { routes } = admin_bro_1.default.Router;
    routes.forEach((route) => {
        const koaPath = route.path.replace(/{/g, ':').replace(/}/g, '');
        const handler = async (ctx, next) => {
            const { request, method, response, params, session } = ctx;
            try {
                const controller = new route.Controller({ admin }, session && session.adminUser);
                const html = await controller[route.action](Object.assign(Object.assign({}, request), { method: method.toLowerCase(), params, query: request.query, payload: Object.assign(Object.assign({}, (request.body || {})), (request.files || {})) }), response);
                if (route.contentType) {
                    response.set({ 'Content-Type': route.contentType });
                }
                if (html) {
                    ctx.body = html;
                }
            }
            catch (e) {
                next(e);
            }
        };
        // if path is an empty string koa-router doesn't apply the prefix correctly hence the workaround
        const pathToNavigate = koaPath === '' ? '/' : koaPath;
        if (route.method === 'GET') {
            router.get(pathToNavigate, handler);
        }
        if (route.method === 'POST') {
            router.post(pathToNavigate, handler);
        }
    });
    const { assets } = admin_bro_1.default.Router;
    assets.forEach((asset) => app.use(koa_mount_1.default(admin.options.rootPath + asset.path, koa_static_1.default(path_1.default.dirname(asset.src), { index: path_1.default.basename(asset.src) }))));
};
exports.addAdminBroRoutes = addAdminBroRoutes;
const verifyAdminBro = (admin) => {
    if (!admin || admin.constructor.name !== constants_1.ADMIN_BRO_PACKAGE_NAME) {
        const e = new Error(constants_1.ADMIN_BRO_ERROR_MESSAGE);
        e.name = constants_1.ADMIN_BRO_ERROR_NAME;
        throw e;
    }
};
exports.verifyAdminBro = verifyAdminBro;
const addAdminBroAuthRoutes = (admin, router, auth) => {
    const { rootPath } = admin.options;
    let { loginPath, logoutPath } = admin.options;
    loginPath = loginPath.replace(constants_1.DEFAULT_ROOT_PATH, '');
    logoutPath = logoutPath.replace(constants_1.DEFAULT_ROOT_PATH, '');
    router.get(loginPath, async (ctx) => {
        ctx.body = await admin.renderLogin({
            action: rootPath + loginPath,
            errorMessage: null,
        });
    });
    router.post(loginPath, async (ctx) => {
        const { email, password } = ctx.request.body;
        const adminUser = await auth.authenticate(email, password);
        if (adminUser) {
            ctx.session.adminUser = adminUser;
            ctx.session.save();
            if (ctx.session.redirectTo) {
                await ctx.redirect(ctx.session.redirectTo);
            }
            else {
                await ctx.redirect(rootPath);
            }
        }
        else {
            ctx.body = await admin.renderLogin({
                action: admin.options.loginPath,
                errorMessage: constants_1.INVALID_CREDENTIALS_ERROR_MESSAGE,
            });
        }
    });
    router.use(async (ctx, next) => {
        if (admin_bro_1.default.Router.assets.find((asset) => ctx.request.originalUrl.match(asset.path))) {
            await next();
        }
        else if (ctx.session.adminUser) {
            await next();
        }
        else {
            const [redirectTo] = ctx.request.originalUrl.split('/actions');
            ctx.session.redirectTo = redirectTo.includes(`${rootPath}/api`) ? rootPath : redirectTo;
            ctx.redirect(rootPath + loginPath);
        }
    });
    router.get(logoutPath, async (ctx) => {
        ctx.session = null;
        ctx.redirect(rootPath + loginPath);
    });
};
exports.addAdminBroAuthRoutes = addAdminBroAuthRoutes;

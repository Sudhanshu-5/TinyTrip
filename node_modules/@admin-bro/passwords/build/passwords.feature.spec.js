"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon_1 = __importDefault(require("sinon"));
const passwords_feature_1 = __importDefault(require("./passwords.feature"));
describe('passwordsFeature', () => {
    let properties;
    let request;
    let context;
    let response;
    let hash;
    beforeEach(() => {
        properties = {
            password: 'visiblePassword',
            encryptedPassword: 'storedPassword',
        };
        hash = sinon_1.default.stub();
        request = {
            method: 'post',
            payload: {},
        };
        response = {
            record: {
                name: 'some Name',
                surname: 'some Surname',
            },
        };
        context = {};
    });
    afterEach(() => {
        sinon_1.default.restore();
    });
    it('returns password feature', async () => {
        chai_1.expect(typeof passwords_feature_1.default({ hash })).to.have.eq('function');
    });
    it('throws an error when hashing function is not defined', () => {
        chai_1.expect(() => {
            passwords_feature_1.default();
        }).to.throw();
    });
    describe('edit#before hook - #encryptPassword', () => {
        let encryptPassword;
        const getBeforeHook = (options) => {
            var _a, _b, _c;
            const feature = passwords_feature_1.default(options)({});
            return (_c = (_b = (_a = feature.actions) === null || _a === void 0 ? void 0 : _a.edit) === null || _b === void 0 ? void 0 : _b.before) === null || _c === void 0 ? void 0 : _c[0];
        };
        beforeEach(() => {
            encryptPassword = getBeforeHook({ properties, hash });
        });
        it('does nothing when method is get', async () => {
            request.method = 'get';
            const ret = await encryptPassword(request, context);
            chai_1.expect(ret).to.deep.eq(request);
        });
        it('des nothing when request doesn\'t have password in the payload', async () => {
            request.payload = {
                [properties.encryptedPassword]: 'someExistingPassword',
            };
            const ret = await encryptPassword(request, context);
            chai_1.expect(ret).to.deep.eq(request);
        });
        it('encrypts the password when it is given and removes the original one', async () => {
            var _a, _b, _c;
            const oldEncrypted = 'someExistingPassword';
            const newEncrypted = 'someNewPassword';
            hash.resolves(newEncrypted);
            request.payload = {
                [properties.encryptedPassword]: oldEncrypted,
                [properties.password]: 'some-new-password',
            };
            const ret = await encryptPassword(request, context);
            chai_1.expect((_a = ret.payload) === null || _a === void 0 ? void 0 : _a[properties.encryptedPassword]).not.to.eq(oldEncrypted);
            chai_1.expect((_b = ret.payload) === null || _b === void 0 ? void 0 : _b[properties.encryptedPassword]).to.eq(newEncrypted);
            chai_1.expect((_c = ret.payload) === null || _c === void 0 ? void 0 : _c[properties.password]).to.be.undefined;
        });
    });
    describe('edit#after hook #movePasswordErrors', () => {
        let movePasswordErrors;
        const getAfterHook = (options) => {
            var _a, _b, _c;
            const feature = passwords_feature_1.default(options)({});
            return (_c = (_b = (_a = feature.actions) === null || _a === void 0 ? void 0 : _a.edit) === null || _b === void 0 ? void 0 : _b.after) === null || _c === void 0 ? void 0 : _c[0];
        };
        beforeEach(() => {
            movePasswordErrors = getAfterHook({ properties, hash });
        });
        it('does nothing when payload doesn\'t have errors', async () => {
            const ret = await movePasswordErrors(response, request, context);
            chai_1.expect(ret).to.deep.eq(response);
        });
        it('moves errors from encryptedPassword to password', async () => {
            const errorMessage = 'password is too short';
            response.record.errors = {
                [properties.encryptedPassword]: errorMessage,
            };
            const ret = await movePasswordErrors(response, request, context);
            chai_1.expect(ret.record.errors[properties.password]).to.deep.eq(errorMessage);
        });
    });
});
